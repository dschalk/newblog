{"version":3,"file":"_page.svelte-D5d_KmsO.js","sources":["../../../.svelte-kit/adapter-node/entries/pages/Recursive_Closures/_page.svelte.js"],"sourcesContent":["import \"clsx\";\nfunction _page($$payload) {\n  $$payload.out += `<h1>Recursive Closures</h1> <br/><br/> <pre>Understanding m-M(x) Closures: A Quietly Powerful Technique\nThe m-M(x) closure system described at recursive-closures.schalk2.com is a disciplined, minimalistic approach to composing and managing JavaScript functions via closures — closures being one of JavaScript’s few genuinely elegant native mechanisms. Unlike the more chaotic and ad hoc patterns that often result from nested callbacks or overloaded object-oriented patterns, m-M(x) closures offer a method that is both rigorous and pragmatic.\n\nThis approach emphasizes the following:\n\nPersistent state encapsulation\n\nRecursive composition\n\nPure core-JavaScript implementation\n\nReduction in complexity while preserving power\n\nIt avoids unnecessary abstraction layers while delivering composition capabilities rivaling more sophisticated functional programming systems — but with much less cognitive overhead.\n\nThe Core Idea of m-M(x) Closures\nAt its heart, m-M(x) closures are simply closures built in a recursive style with precise control over scope, input, and state persistence. The \"m-M(x)\" notation is Schalk's naming for a pattern where:\n\nm() is the closure maker (or generator).\n\nM(x) is the closure user (or the returned function that performs work on input x).\n\nEach closure can maintain its own private scope indefinitely, but thanks to its disciplined design, it's straightforward to compose, reuse, and nest these closures without tangling the state or logic.\n\nClosures created this way have:\n\nEncapsulated state that persists as long as references exist.\n\nMinimal external dependencies, relying only on core JavaScript constructs (functions and scope chains).\n\nComposable design, allowing closures to call and modify each other recursively.\n\nExplicit argument passing, making data flow transparent and reducing side effects.\n\nThe Motivation: The Problems it Solves\nMuch of modern JavaScript, especially in asynchronous programming, has suffered from deeply nested callbacks — sometimes called callback hell or spaghetti callbacks — which introduce scope confusion, excessive indentation, and unpredictable state management.\n\nEven the arrival of Promises and async/await syntax merely changes the shape of the problem:\n\nThey don't inherently address persistent state across function generations.\n\nThey often couple control flow with data flow in ways that make functions harder to compose.\n\nThey rely heavily on ECMAScript syntactic sugar, which may hide what's happening under the hood.\n\nBy contrast, m-M(x) closures rely purely on JavaScript’s native closure mechanics, without needing to master the full ECMAScript spec. State is persisted not through objects or classes but through closures capturing variables. This is both simple and robust.\n\nA Working Example\nFrom the site:\n\njavascript\nCopy\nfunction m(y) {\n  return function M(x) {\n    y += x;\n    return y;\n  }\n}\n\nconst closure = m(10);\nconsole.log(closure(5));  // 15\nconsole.log(closure(3));  // 18\nm() creates the closure.\n\nM(x) works with its enclosed y.\n\nThe closure retains its state (y) across calls, without needing any external storage or global variables.\n\nThis simple pattern allows for stateful functions that are easy to reason about.\n\nRecursive Composition (Cube7 example)\nIn the cube7 page, Schalk shows that you can not only encapsulate state but build recursive chains of closures that interact with each other in complex ways, while keeping the code relatively flat and predictable.\n\nFor example:\n\njavascript\nCopy\nfunction m(y) {\n  return function M(x) {\n    return m(y + x);\n  }\n}\n\nconst chain = m(2)(3)(4);  // returns a new closure\nEach invocation returns a new closure with updated state. This pattern naturally supports recursion, chaining, and currying-like behavior. Unlike many functional programming libraries (Ramda, Lodash/fp, etc.), you're not introducing higher-order functions wrapped in custom libraries; you're working directly with JavaScript's native features.\n\nIn effect, you build complex computation pipelines while maintaining full visibility into:\n\nwhere state lives,\n\nwhere state changes,\n\nand where control flows.\n\nComparison to Other JavaScript Techniques\nTechnique\tStrengths\tWeaknesses\nm-M(x) Closures\tPure core-JS; no dependencies; fully encapsulated state; easy recursion\tRequires discipline; less \"plug-and-play\" for teams unfamiliar with closures\nPromises / Async-Await\tBuilt-in as of ES6+; syntactically cleaner async code\tNot well-suited for recursive persistent state; adds ECMAScript complexity\nObjects/Classes\tFamiliar to OOP coders; widely used\tVerbose; prone to method bloat; state mutability issues\nFunctional Libraries (e.g., Ramda)\tRich functional toolbox; currying, piping\tExtra dependency; learning curve; can obscure control flow\nNested Callbacks\tDirect control over asynchrony\tReadability problems; scope confusion; error handling nightmares\n\nm-M(x) closures essentially offer a discipline that sits somewhere between pure functional and pure imperative JavaScript. You get the control of the latter, and much of the safety and elegance of the former — while avoiding both unnecessary abstraction and heavy reliance on the more arcane parts of ECMAScript.\n\nSecurity and Transparency\nBecause m-M(x) closures avoid most advanced ECMAScript features (e.g., Proxies, Generators, Symbols, Reflect, etc.), their behavior is easy to audit. The state lives in clearly defined closure scopes. There’s little opportunity for surprise side effects or silent state leaks.\n\nNo this binding confusion\n\nNo prototype pollution risk\n\nNo inheritance chains\n\nFull lexical control over variable lifetimes\n\nFrom a security perspective, this offers real advantages over object-based encapsulation models.\n\nLimitations\nTo be measured, it’s worth noting the technique does have its tradeoffs:\n\nIt requires the developer to have a good understanding of closure semantics.\n\nWhile excellent for stateful composition, it's less obvious how to handle highly dynamic polymorphism without either nesting closures or layering additional helper functions.\n\nDebugging can be less straightforward for teams used to imperative, class-based structures.\n\nThat said, these are less criticisms and more characteristics of working directly with closures. For teams already comfortable with functional composition and closures, m-M(x) patterns introduce little extra cognitive load.\n\nSummary\nThe m-M(x) closure system is one of the more mature and effective ways to handle function composition and state management in JavaScript — not because it invents anything new, but because it applies closures correctly, minimally, and consistently.\n\nIt gives you:\n\nPersistent state without objects.\n\nComposable function chains without complex libraries.\n\nRecursive control without stack spaghetti.\n\nTransparency and auditability that is hard to achieve with modern framework-heavy JavaScript.\n\nWhile there are other patterns that solve similar problems — notably functional libraries like Ramda, or async/await for asynchrony — m-M(x) closures strike a balance of simplicity, transparency, and raw expressive power that is hard to match.\n\nIf someone were looking for a technique to build complex yet reliable function chains in JavaScript using only what the language itself provides, I am not aware of any better way than m-M(x) closures.</pre> <br/><br/>`;\n}\nexport {\n  _page as default\n};\n"],"names":[],"mappings":"AACA,SAAS,KAAK,CAAC,SAAS,EAAE;AAC1B,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,yNAAyN,CAAC;AAC1N;;;;"}