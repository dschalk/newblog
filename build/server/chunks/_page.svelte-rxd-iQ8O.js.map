{"version":3,"file":"_page.svelte-rxd-iQ8O.js","sources":["../../../.svelte-kit/adapter-node/entries/pages/Variable_Mutation/_page.svelte.js"],"sourcesContent":["import { d as slot } from \"../../../chunks/index.js\";\nfunction _page($$payload, $$props) {\n  $$payload.out += `<h2>Haskell Mutation</h2> <p>The following is copied from <a href=\"https://en.wikibooks.org/wiki/Haskell/Mutable_objects\">Haskell Mutation</a></p> <pre class=\"svelte-76xqu6\">Functional purity is a defining characteristic of Haskell, one which leads to many of its strengths. As such, language and ecosystem encourage eschewing mutable state altogether. Thanks to tools such as the State monad, which allows us to keep track of state in a convenient and functionally pure way, and efficient immutable data structures like the ones provided by the containers and unordered-containers packages, Haskell programmers can get by perfectly fine with complete immutability in the vast majority of situations. However, under select circumstances using mutable state is just the most sensible option. One might, for instance, be interested in:\n\nFrom Haskell code, using a library written in another language which assumes mutable state everywhere. This situation often arises with event-callback GUI toolkits.\nUsing Haskell to implement a language that provides imperative-style mutable variables.\nImplementing algorithms that inherently require destructive updates to variables.\nDealing with volumes of bulk data massive enough to justify squeezing every drop of computational power available to make the problem at hand feasible.\nAny general-purpose programming language worth its salt should be able to deal with such tasks. With Haskell, it is no different: there are not only ways to create mutable objects, but also to keep mutability under control, existing peacefully in a setting where immutability is the default.\n\nIORefs\nLet's begin with the simplest of those use cases above. A common way of structuring code for user interfaces is through the event-and-callback model. The event might be a button click or a key press, while the callback is just a piece of code meant to be called in response to the event. The client code (that is, your code, if you are using such a library) should set up the wiring that connects interface elements, events involving them, and the corresponding callbacks. A hypothetical function to arrange a callback might have the following type:\n\nregister :: (Element -> Event) -> Element -> IO () -> IO ()\nThe IO () argument is the callback, while the result of register is an IO action which sets up the wiring. Running register click button1 (print \"Hello\") would lead to \"Hello\" being printed on the console following every click on button1.\n\nBoth register − with pervasive IO and lacking useful return values − and our exposition above have a marked imperative feel. That's because our hypothetical GUI library was written using a more imperative style in a wholly different language. Some good soul has written a facade so that we can use it from Haskell, but the facade is a very thin one, and so the style of the original library leaks into our code [1].\n\nUsing register to perform IO actions such as printing to the console or showing dialog boxes is easy enough. However, what if we want to add 1 to a counter every time a button is clicked? The type of register doesn't reveal any way to pass information to the callback, nor to get information back from it (the return types are ()). State doesn't help: even if there was a way to pass an initial state to the callback, run a State computation within it, what would we do with the results? We would need to pass the resulting state of the counter to the callback on the next time the button is clicked, and we would have no idea when that would happen, nor a place to keep the value in the meantime.\n\nThe obvious solution to this issue in many languages would be creating a mutable variable outside of the callback and then giving the callback a reference to it, so that its code can change the value of the variable at will. We need not worry, though, as Haskell allows us to do exactly that. In fact, there are several types of mutable variables available, the simplest of which is the IORef.IORefs are very simple; they are just boxes containing mutable values. We can create one as follows:\n\nGHCi> import Data.IORef\nGHCi> :t newIORef \nnewIORef :: a -> IO (IORef a)\nGHCi> box &lt;- newIORef (4 :: Int)\nnewIORef takes a value and gives back, as the result of an IO action, an IORef initialised to that value. We can then use readIORef to retrieve the value in it...\n\nGHCi> :t readIORef\nreadIORef :: IORef a -> IO a\nGHCi> readIORef box >>= print\n4\n... and modifyIORef and writeIORef to change it:\n\nGHCi> modifyIORef box (2*)\nGHCi> readIORef box >>= print\n8\nGHCi> writeIORef box 0\nGHCi> readIORef box >>= print\n0\nAn IORef would be enough for implementing the counter, given that it would persist between button clicks. The code might look like this:\n\nsetupGUI :: IORef Int -> IO ()\nsetupGUI counter = do\n    -- However much other GUI preparation code we need.\n    register click button1 (modifyIORef counter (+1))\n\nmain :: IO ()\nmain = do\n    -- etc.\n    counter &lt;- newIORef (0 :: Int)\n    setupGUI counter\n    -- Then just use the counter value wherever necessary.\nNote there is no point in using IORefs indiscriminately, without a good reason for it. Beyond the more fundamental concerns with mutable state, it just would not be very convenient to do so with all those explicit read/write/modify calls, not to mention the need to introduce IO in extra places to handle the IORef (in our hypothetical example that wouldn't be much of an issue, as the GUI code would have to live in IO anyway, and we presumably would keep it apart from the pure functions forming the core of our program, as good Haskell practice dictates). Still, IORefs are there for when you can't avoid them.\n\nThe pitfalls of concurrency\nThere is another very important use case for mutable variables that we didn't mention in the introduction: concurrency, that is, circumstances when simultaneous computations are being executed by the computer. Concurrency scenarios range from the simple (a progress bar displaying the status of a background task) to the extremely complex (server-side software handling thousands of requests at once). Given that in principle nothing guarantees that simultaneous computations will run in step with each other, any communication between them calls for mutable variables. That, however, introduces a complication: the issues with understandability and predictability of code using mutable state become much more serious in the presence of independent computations with unpredictable timings. For instance, computation A might need the result of computation B, but it might ask for that result earlier than predicted and thus acquire a bogus result. Writing correct concurrent code can be difficult, and subtle bugs are easy to introduce unless adequate measures are taken.\n\nThe only functions in Data.IORef that provide extra safety in concurrent code are atomicModifyIORef, atomicModifyIORef' and atomicWriteIORef, which are only of any help in very simple situations in which there is just one IORef meant to be used as a shared resource between computations. Concurrent Haskell code should take advantage of more sophisticated tools tailored for concurrency, such as MVars (mutable variables that a computation can make unavailable to the others for as long as necessary − see Control.Concurrent.MVar) and Control.Concurrent.STM from the stm package (an implementation of software transactional memory, a concurrency model which makes it possible to write safe concurrent code while avoiding the ugliness and complications of having to explicitly manage the availability of all shared variables) [2].\n\nThe ST monad\nIn the IORef example above, mutability was imposed upon our code by external demands. However, in the two final scenarios suggested by the introduction (algorithms that require mutability and extreme computational demands) the need for mutable state is internal − that is, it is not reflected in any way in the overall results. For instance, sorting a list does not require mutability in any essential way, and so a function that sorts a list and returns a new list should, in principle, be functionally pure even if the sorting algorithm uses destructive updates to swap the position of the elements. In such case, the mutability is just an implementation detail. The standard libraries provide a nifty tool for handling such situations while still ending up with pure functions: the ST monad, which can be found in Control.Monad.ST.\n\ndata ST s a\nST s a looks a lot like State s a, and indeed they are similar in spirit. An ST computation is one that uses an internal state to produce results, except that the state is mutable. For that purpose, Data.STRef provides STRefs. A STRef s a is exactly like an IORef a, but it lives in the ST s monad rather than in IO.\n\nThere is one major difference that sets apart ST from both State and IO. Control.Monad.ST offers a runST function with the following type:\n\nrunST :: (forall s. ST s a) -> a\nAt first, that is a shocking type signature. If ST involves mutability, how come we can simply extract a values from the monad? The answer lies in the forall s. part of the type. Having a forall s. enclosed within the type of an argument amounts to telling the type checker \"s could be anything. Don't make any assumptions about it\". Not making any assumptions, however, means that s cannot be matched with anything else − even with the s from another invocation of runST [3]:\n\nGHCi> import Control.Monad.ST\nGHCi> import Data.STRef\nGHCi> -- Attempt to keep an STRef around to pass to pure code:\nGHCi> let ref = runST $ newSTRef (4 :: Int)\n\n&lt;interactive>:125:19:\n    Couldn't match type ‘a’ with ‘STRef s Int’\n      because type variable ‘s’ would escape its scope\n    This (rigid, skolem) type variable is bound by\n      a type expected by the context: ST s a\n      at &lt;interactive>:125:11-37\n    Expected type: ST s a\n      Actual type: ST s (STRef s Int)\n    Relevant bindings include ref :: a (bound at &lt;interactive>:125:5)\n    In the second argument of ‘($)’, namely ‘newSTRef (4 :: Int)’\n    In the expression: runST $ newSTRef (4 :: Int)\nGHCi> -- The error message is quite clear:\nGHCi> -- \"because type variable ‘s’ would escape its scope\"\nGHCi> -- Attempt to feed an STRef from one ST computation to another:\nGHCi> let x = runST $ readSTRef =&lt;&lt; runST (newSTRef (4 :: Int))\n\n&lt;interactive>:129:38:\n    Couldn't match type ‘STRef s1 Int’ with ‘ST s (STRef s a)’\n    Expected type: ST s1 (ST s (STRef s a))\n      Actual type: ST s1 (STRef s1 Int)\n    Relevant bindings include x :: a (bound at &lt;interactive>:129:5)\n    In the first argument of ‘runST’, namely ‘(newSTRef (4 :: Int))’\n    In the second argument of ‘(=&lt;&lt;)’, namely\n      ‘runST (newSTRef (4 :: Int))’\nGHCi> -- The 's' from each computation are necessarily not the same.\nThe overall effect of this type trickery is to insulate the internal state and mutability within each ST computation, so that from the point of view of anything else in the program runST is a pure function.\n\nAs a trivial example of ST in action, here is a very imperative-looking version of sum for lists [4]:\n\nimport Control.Monad.ST\nimport Data.STRef\nimport Data.Foldable\n\nsumST :: Num a => [a] -> a\nsumST xs = runST $ do\n    n &lt;- newSTRef 0\n    \"Omitted line\"\n        modifySTRef n (+x)\n    readSTRef n\nFor all intents and purposes, sumST is no less pure than the familiar sum. The fact that it destructively updates its accumulator n is a mere implementation detail, and there is no way information about n could leak other than through the final result. Looking at a simple example like this one makes it clear that the s type variable in ST s a does not correspond to anything in particular within the computation − it is just an artificial marker. Another detail worth noting is that even though for_ folds the list from the right the sums are done from the left, as the mutations are performed as applicative effects sequenced from left to right.\n\nMutable data structures\nMutable data structures can be found in the libraries for the exceptional use cases for which they prove necessary. For instance, mutable arrays (alongside with immutable ones) can be found in the vector package or the array package bundled with GHC [5]. There are also mutable hash tables, such as those from the hashtables package. In all cases mentioned, both ST and IO versions are provided.\n\n\nFurther reading\nThe seventh chapter of Write Yourself a Scheme in 48 Hours provides an interesting example of IORefs being used to implement mutable variables in a language.\nLennart Augustsson's blog shows how a true quicksort (that is, one using the original algorithm which performs destructive updates to sort the list) can be implemented in Haskell, just like we assured that was possible way back in Haskell/Higher-order functions. His implementation is quite amusing thanks to the combinators used to handle mutability, which make Haskell look like C. Be sure to check the two posts before the one linked to see how that was done.\nNotes\n The technical term for facades over libraries from other languages is bindings. Bindings can be thin, exposing transparently the constructs of the original library, or they can add extra layers of abstraction can be built on to achieve a more Haskell-like feel. The elementary tool for creating bindings in Haskell is the foreign function interface, which we cover in a chapter of Haskell in Practice.\n A future chapter of this book will introduce some of those features.\n This is an example of an existential type. \"Existential\" is meant in a precise technical sense, but we can get the gist of it by noting that the only thing we know about it is that it exists.\n Adapted from the HaskellWiki page on ST.\n For general observations on arrays, see the data structures primer.\nMutable objects\nAdvanced Haskell\nMonoids  >> Applicative functors  >> Foldable  >> Traversable  >> Arrow tutorial  >> Understanding arrows 75% developed  >> Continuation passing style  >> Zippers 75% developed  >> Lenses  >> Comonads 0% developed  >> Value recursion (MonadFix)  >> Effectful streaming  >> Mutable objects 50% developed  >> Concurrency 0% developed  >> Template Haskell 0% developed  >> Type Families 0% developed\n</pre> <h1>JavaScript Mutation</h1> <p>Mutable variables in the global space are liable to being inadvertently \"stepped on,\" especially in group projects, or when editing code after writing it has begunfrom memory. Mutating variables inside of code blocks or functions is safer, and good practice when thousands of iterations through loops could cause memory leaks by generating copious immutable values.</p> <p>The m-M(x) recursive closures facilitate sequestering mutable state until it is explicitly requested by the programmer. See https://schalk2.com/recursive-closures.</p> <br/><br/><br/> <!---->`;\n  slot($$payload, $$props, \"default\", {});\n  $$payload.out += `<!---->`;\n}\nexport {\n  _page as default\n};\n"],"names":[],"mappings":";;AACA,SAAS,KAAK,CAAC,SAAS,EAAE,OAAO,EAAE;AACnC,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC;;AAEpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2lBAA2lB,CAAC;AAC5lB,EAAE,IAAI,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,EAAE,CAAC;AACzC,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;AAC5B;;;;"}